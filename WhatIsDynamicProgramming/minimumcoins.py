import math
"""
Given a set of coin values coins={c1, c2, ..., ck} and a target sum of money, m, what's the minimum number of coins
that form the sum m
"""

# I got it right first try!
# Let's consider the theory behind my answer.

# We are always choosing the largest possible coin until we get to the target amount.
# This is called a Greedy approach, because we're choosing the greediest option every time,
# and this works for euro-coins

# So, I solved this using a Greedy solution. This works in the case of Euro-coins, but not in the general case. For example, see the two print statements below.
def minimumCoins(coins, sum):
    if coins == []:
        return 0
    else:
        numberOfMaxCoins = math.floor(sum / coins[-1])
        print(numberOfMaxCoins)
        return numberOfMaxCoins + minimumCoins(coins[:-1], sum - numberOfMaxCoins * coins[-1])
    
# print(minimumCoins([1,2,5,10,20,50,100,200], 743))
# print(minimumCoins([1, 4, 5], 13))

# Can we use Dynamic programming to solve this problem?
# What sub-problems do we need to solve?
# It's usually a good idea to consider the final question you're trying to answer to also be the sub-problem for dynamic programming

memo = {}
def dynamicMinimumCoins(coins, sum):
    if sum == 0:
        return 0
    # We now solve the sub-problem, minimum coins of m, when m > 0 --> Sketch a tree of the 13 problem, 
    # where each subsequent layer is generated by the result of subtracting a coin in coins from our sum
    # mathematically, solution(m) = min_{c \in coins} solution (m - c) + 1
    # Below is the naive solution, where we implement mathematically, the things above
    else:
        possibilities = [(sum-coins[i]) for i in range(0, len(coins)) if (sum-coins[i]) >= 0]
        """
        print(f"possibilities are {possibilities}")
        possible_paths = [dynamicMinimumCoins(coins, possibilities[i]) for i in range(0, len(possibilities)) if possibilities[i] not in memo else memo[i]]
        print(f"potential paths are {possible_paths}")
        """
        possible_paths = []
        for i in range(0, len(possibilities)):
            if possibilities[i] in memo:
                possible_paths.append(memo[i])
            else:
                result = dynamicMinimumCoins(coins, possibilities[i])
                memo[possibilities[i]] = result    
                possible_paths.append(result)

        if possible_paths == []:
            return 0
        else:
            return 1 + min(possible_paths)
    
# print(dynamicMinimumCoins([1,4,5], 13))
# print(dynamicMinimumCoins([1,2,5,10,20,50,100,200], 100))

# The above didn't work. I will try and find the reason why in a moment.
# Their correct solution is as follows:
def min_ignore_none(a, b):
    if a is None:
        return b
    if b is None:
        return a
    return min(a, b)

def minimum_coins(m, coins):
    if m in memo:
        return memo[m]
    if m == 0:
        answer = 0
    else:
        answer = None
        for coin in coins:
            subproblem = m - coin
            if subproblem < 0:
                # skip solutions for a negative subproblem
                continue
            answer = min_ignore_none(answer,
                                     minimum_coins(subproblem, coins) + 1)
    
    memo[m] = answer
    return answer

print(minimum_coins(13, [1,4,5]))

print(minimum_coins(150, [1,4,5]))

# Time complexity O(M * K)
# We now look at the bottom-up solutions
# Slightly lower constant factor, and is slightly shorter, so he prefers it
def minimum_coins(m, coins):
    memo2 = {}
    memo2[0] = 0
    for i in range(1, m+1):
        for coin in coins:
            subproblem = i - coin
            if subproblem < 0:
                continue

            memo2[i] = min_ignore_none(memo.get(i), memo.get(subproblem) + 1)
    return memo2[i]